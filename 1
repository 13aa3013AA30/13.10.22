# -*- coding: utf-8 -*-
"""task

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g45IbRoRMmGoj-3QgrzzSNIMeqOk7Au1
"""

# Ниже приведена функция, работающая со списками, в ней есть баг. Исходя из описания функции,
# найдите в ней баг

def has_lucky_number(nums):
    """Возвращает, является ли данный список чисел счастливым. Счастливый список должен
    содержать по крайней мере одно число, кратное 7
    """
    for num in nums:
        if num % 7 == 0:
            return True

# Реализуйте функцию is_year_leap, которая принимает на вход год,
# и возвращает информацию о том, является ли год високосным

# https://ru.wikihow.com/%D0%B2%D1%8B%D1%81%D1%87%D0%B8%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%B2%D0%B8%D1%81%D0%BE%D0%BA%D0%BE%D1%81%D0%BD%D1%8B%D0%B5-%D0%B3%D0%BE%D0%B4%D1%8B

def is_year_leap(year):
    return year % 4==0 and year %100 != 0 or year % 400 ==0

# Написать функцию square, принимающую 1 аргумент — сторону квадрата,
# и возвращающую 3 значения (в виде кортежа): периметр квадрата,
# площадь квадрата и диагональ квадрата

def square_statistcis(square):
    p=side*4
    s=side**2
    d=side*2**0.5
    return(p,s,d)

#Пользователь делает вклад в размере a рублей сроком на years лет под m% годовых (каждый год размер его вклада
# увеличивается на m%. Эти деньги прибавляются к сумме вклада, и на них в следующем году тоже будут проценты).
#Написать функцию count_money, принимающая аргументы initial_money_amount,
# percent и years, и возвращающую сумму, которая будет на счету пользователя к концу переиода

def count_money(initial_money_amount, percent, years):
   return initial_money_amount*((1+percent/100)**years)

# Предлагается реализовать функцию, сравнивающую каждый элемент списка с заданным числом.

def elementwise_greater_than(L, thresh):
    """Возвращает список той же длины, что и L, где значение в индексе i равно
    True, если L[i] больше порогового значения, и False в противном случае """
    return(item > thresh for item in L)

assert(elementwise_greater_than([1, 2, 3, 4], 2) == [False, False, True, True])

def is_valid_zip(zip_code):
    """Проверяет индес на валидность. Будем считать, что почтовый индекс валиден, если он состоит из 6 цифр"""
    return len(zip_code)==6 and zip_code.isdigit()

assert(is_valid_zip('123456') == True)
assert(is_valid_zip('12345a') == False)

# Исследователь собрал тысячи новостных статей. Ему требуется отобрать из этих статей лишь те,
# которые содержат определенное слово. Закончите функцию ниже.

# - Документы содержащие искомое слово внутри другого не должны учитываться (например слово
# "москит", если мы ищем документы со словом "кит")
# - Слова написанные буквами в разном регистре это одни и те же слова (например "кот" то же, что и
# "Кот")
# - Если за словом идет знак препинания, это не должно влиять на поиск (например, если в тексте
# есть "башмак, который порван", то по слову "башмак" мы должны выдавать этот текст)
import string
def word_search(doc_list, keyword):
    """
    Принимает список документов doc_list (каждый документ представляет собой строку) и ключевое слово.
    Возвращает список значений индекса в исходный список для всех документов, содержащих ключевое слово. """
document_indexes=[]
doc_list = ["Москит укусил туриста", "Кит, в Тихом океане", "Кот-бегемот"]
for index, document in enumerate(doc_list):
    for word in document.split():
        if keyword.lower()==word.lower().translate(str.maketrans('','', string.punctuation)):
            document_indexes.append(index)
print(word_search(doc_list, 'кит'))

# EXTRA TASK 1
# Рассчитать ежемесячные выплаты (m) и суммарную выплату (s) по кредиту.
# О кредите известно, что он составляет n рублей, берется на y лет, под p процентов
# Месячные выплаты находятся по формуле:
# m = (n * p * (1 + p)y) / (12 * ((1 + p)y – 1)), где p выражается в долях единицы, а не процентах.

#Суммарная выплата представляет собой выплаты за все месяцы каждого года:
# s = (m * 12) * y
def ezemecechnai_vyplata(n,f,y):
    f=f/100
    m=(n * f * (1 + f)**y) / (12 * ((1 + f)**y – 1))
    s = (m*12)* y
    return m,s
print(ezemecechnai_vyplata(n,f,y))



# EXTRA TASK 2
# Написать функцию XOR_cipher, принимающая 2 аргумента: строку, которую нужно зашифровать,
# и ключ шифрования, которая возвращает строку, зашифрованную путем применения функции XOR (^)
# над символами строки с ключом. Написать также функцию XOR_uncipher, которая по зашифрованной
# строке и ключу восстанавливает исходную строку.
def XOR_cipher (string, key):
    result = ''
    for i in range(len(string)):
        result += chr(ord(string[i]) ^ ord(key[i]))

    return result
def XOR_uncipher (string, key):
    result = ''
    for i in range(len(string)):
        result += chr(ord(string[i]) ^ ord(key[i]))

    return result

#XOR_cipher = XOR_uncipher






# EXTRA TASK 3
# Написать функцию date, принимающую 3 аргумента — день, месяц и год. Вернуть True,
# если такая дата есть в нашем календаре, и False иначе (воспользуйтесь функцией is_leap_year)

def date(day, month, year):
    if month in [1,3,5,7,8,10,12] and 1<= day <=31:
        return True
    elif month in [ 4, 6, 9, 11] and 1 <= day <= 30:
        return True
    elif month==2 and (is_year_leap(year) and 1<=day<=29 or not is_year_leap(year) and 1<=day<=28):
        return True
    else:
        return False

